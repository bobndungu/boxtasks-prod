<?php

/**
 * @file
 * BoxTasks Role module for workspace-based role permissions.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Session\AccountInterface;
use Drupal\node\NodeInterface;

/**
 * Implements hook_node_access().
 */
function boxtasks_role_node_access(NodeInterface $node, $op, AccountInterface $account) {
  $type = $node->bundle();

  // workspace_role and member_role nodes are accessible to all authenticated users.
  // These are needed for role management and member assignment functionality.
  if (in_array($type, ['workspace_role', 'member_role'])) {
    if ($account->isAuthenticated()) {
      return AccessResult::allowed()
        ->cachePerUser()
        ->addCacheableDependency($node);
    }
    return AccessResult::forbidden()->cachePerUser();
  }

  // Define which content types we handle.
  $handled_types = ['board', 'workspace', 'card', 'list', 'card_comment', 'checklist', 'checklist_item'];
  if (!in_array($type, $handled_types)) {
    return AccessResult::neutral();
  }

  // Super admins (Box Admin) bypass all checks.
  // Check both permission and role to ensure administrators always have access.
  if ($account->hasPermission('administer nodes') || boxtasks_role_is_super_admin($account)) {
    return AccessResult::allowed()->cachePerPermissions()->cachePerUser();
  }

  // Get the permission checker service.
  /** @var \Drupal\boxtasks_role\Service\PermissionChecker $permission_checker */
  $permission_checker = \Drupal::service('boxtasks_role.permission_checker');

  // Normalize operation - treat 'view revision' as 'view' for access purposes.
  // JSON:API uses 'view revision' when fetching content.
  $normalized_op = ($op === 'view revision') ? 'view' : $op;

  // Handle 'create' operation specially for ALL types.
  // Create operations need special handling because parent references may be partial.
  if ($normalized_op === 'create') {
    return boxtasks_role_check_create_access($node, $type, $account, $permission_checker);
  }

  // Handle card, list, and related types - access is based on board access.
  if (in_array($type, ['card', 'list', 'card_comment', 'checklist', 'checklist_item'])) {
    return boxtasks_role_check_board_based_access($node, $type, $normalized_op, $account, $permission_checker);
  }

  // Map operation to permission field for board and workspace.
  $permission_map = [
    'board' => [
      'view' => 'field_perm_board_view',
      'update' => 'field_perm_board_edit',
      'delete' => 'field_perm_board_delete',
    ],
    'workspace' => [
      'view' => 'field_perm_workspace_view',
      'update' => 'field_perm_workspace_edit',
      'delete' => 'field_perm_workspace_delete',
    ],
  ];

  if (!isset($permission_map[$type][$normalized_op])) {
    return AccessResult::neutral();
  }

  $permission_field = $permission_map[$type][$normalized_op];

  // For board view operations, use the specialized canViewBoard method
  // which handles board membership in addition to role permissions.
  if ($type === 'board' && $normalized_op === 'view') {
    $has_permission = $permission_checker->canViewBoard($node, (int) $account->id());

    if ($has_permission) {
      return AccessResult::allowed()
        ->cachePerUser()
        ->addCacheableDependency($node)
        ->addCacheTags(['node_list:member_role']);
    }

    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheTags(['node_list:member_role']);
  }

  // Get workspace ID for other operations.
  if ($type === 'board') {
    if (!$node->hasField('field_board_workspace')) {
      // No workspace field - deny access for security.
      return AccessResult::forbidden()
        ->cachePerUser()
        ->addCacheableDependency($node);
    }
    $workspace_ref = $node->get('field_board_workspace')->entity;
    if (!$workspace_ref) {
      // No workspace assigned - deny access for security.
      return AccessResult::forbidden()
        ->cachePerUser()
        ->addCacheableDependency($node);
    }
    $workspace_id = $workspace_ref->uuid();
  }
  else {
    $workspace_id = $node->uuid();
  }

  // Check permission.
  $owner_id = (int) $node->getOwnerId();
  $has_permission = $permission_checker->checkPermission(
    $permission_field,
    $workspace_id,
    $owner_id,
    $account->id()
  );

  if ($has_permission) {
    return AccessResult::allowed()
      ->cachePerUser()
      ->addCacheableDependency($node);
  }

  return AccessResult::forbidden()
    ->cachePerUser()
    ->addCacheableDependency($node);
}

/**
 * Check access for card, list, and related types based on board access.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The node being accessed.
 * @param string $type
 *   The node type (card, list, card_comment, checklist, checklist_item).
 * @param string $op
 *   The operation (view, update, delete).
 * @param \Drupal\Core\Session\AccountInterface $account
 *   The user account.
 * @param \Drupal\boxtasks_role\Service\PermissionChecker $permission_checker
 *   The permission checker service.
 *
 * @return \Drupal\Core\Access\AccessResultInterface
 *   The access result.
 */
function boxtasks_role_check_board_based_access(NodeInterface $node, string $type, string $op, AccountInterface $account, $permission_checker) {
  // Get the board for this entity.
  $board = boxtasks_role_get_board_for_entity($node, $type);

  if (!$board) {
    // No board found - deny access for security.
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node);
  }

  // For view operations, check if user can view the board.
  if ($op === 'view') {
    $can_view = $permission_checker->canViewBoard($board, (int) $account->id());
    if ($can_view) {
      return AccessResult::allowed()
        ->cachePerUser()
        ->addCacheableDependency($node)
        ->addCacheableDependency($board)
        ->addCacheTags(['node_list:member_role']);
    }
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board)
      ->addCacheTags(['node_list:member_role']);
  }

  // For update/delete, first check board access, then check specific permissions.
  $can_view_board = $permission_checker->canViewBoard($board, (int) $account->id());
  if (!$can_view_board) {
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board)
      ->addCacheTags(['node_list:member_role']);
  }

  // Get workspace from board.
  if (!$board->hasField('field_board_workspace') || $board->get('field_board_workspace')->isEmpty()) {
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board);
  }
  $workspace = $board->get('field_board_workspace')->entity;
  if (!$workspace) {
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board);
  }

  // Map type and operation to permission field.
  $permission_map = [
    'card' => [
      'update' => 'field_perm_card_edit',
      'delete' => 'field_perm_card_delete',
    ],
    'list' => [
      'update' => 'field_perm_list_edit',
      'delete' => 'field_perm_list_delete',
    ],
    'card_comment' => [
      'update' => 'field_perm_comment_edit',
      'delete' => 'field_perm_comment_delete',
    ],
    'checklist' => [
      'update' => 'field_perm_card_edit',
      'delete' => 'field_perm_card_delete',
    ],
    'checklist_item' => [
      'update' => 'field_perm_card_edit',
      'delete' => 'field_perm_card_delete',
    ],
  ];

  if (!isset($permission_map[$type][$op])) {
    return AccessResult::neutral();
  }

  $permission_field = $permission_map[$type][$op];
  $owner_id = (int) $node->getOwnerId();

  $has_permission = $permission_checker->checkPermission(
    $permission_field,
    $workspace->uuid(),
    $owner_id,
    $account->id()
  );

  if ($has_permission) {
    return AccessResult::allowed()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board)
      ->addCacheableDependency($workspace);
  }

  return AccessResult::forbidden()
    ->cachePerUser()
    ->addCacheableDependency($node)
    ->addCacheableDependency($board)
    ->addCacheableDependency($workspace);
}

/**
 * Get the board associated with a card, list, or related entity.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The node.
 * @param string $type
 *   The node type.
 *
 * @return \Drupal\node\NodeInterface|null
 *   The board node or NULL.
 */
function boxtasks_role_get_board_for_entity(NodeInterface $node, string $type): ?NodeInterface {
  switch ($type) {
    case 'list':
      // List -> Board.
      if ($node->hasField('field_list_board') && !$node->get('field_list_board')->isEmpty()) {
        return $node->get('field_list_board')->entity;
      }
      return NULL;

    case 'card':
      // Card -> List -> Board.
      if ($node->hasField('field_card_list') && !$node->get('field_card_list')->isEmpty()) {
        $list = $node->get('field_card_list')->entity;
        if ($list && $list->hasField('field_list_board') && !$list->get('field_list_board')->isEmpty()) {
          return $list->get('field_list_board')->entity;
        }
      }
      return NULL;

    case 'card_comment':
      // Card comment -> Card -> List -> Board.
      if ($node->hasField('field_comment_card') && !$node->get('field_comment_card')->isEmpty()) {
        $card = $node->get('field_comment_card')->entity;
        if ($card) {
          return boxtasks_role_get_board_for_entity($card, 'card');
        }
      }
      return NULL;

    case 'checklist':
      // Checklist -> Card -> List -> Board.
      if ($node->hasField('field_checklist_card') && !$node->get('field_checklist_card')->isEmpty()) {
        $card = $node->get('field_checklist_card')->entity;
        if ($card) {
          return boxtasks_role_get_board_for_entity($card, 'card');
        }
      }
      return NULL;

    case 'checklist_item':
      // Checklist item -> Checklist -> Card -> List -> Board.
      if ($node->hasField('field_checklist_item_checklist') && !$node->get('field_checklist_item_checklist')->isEmpty()) {
        $checklist = $node->get('field_checklist_item_checklist')->entity;
        if ($checklist) {
          return boxtasks_role_get_board_for_entity($checklist, 'checklist');
        }
      }
      return NULL;
  }

  return NULL;
}

/**
 * Check create access for all handled content types.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The node being created (may have partial data).
 * @param string $type
 *   The node type.
 * @param \Drupal\Core\Session\AccountInterface $account
 *   The user account.
 * @param \Drupal\boxtasks_role\Service\PermissionChecker $permission_checker
 *   The permission checker service.
 *
 * @return \Drupal\Core\Access\AccessResultInterface
 *   The access result.
 */
function boxtasks_role_check_create_access(NodeInterface $node, string $type, AccountInterface $account, $permission_checker) {
  // Map type to create permission field.
  $create_permission_map = [
    'board' => 'field_perm_board_create',
    'card' => 'field_perm_card_create',
    'list' => 'field_perm_list_create',
    'card_comment' => 'field_perm_card_create',
    'checklist' => 'field_perm_card_create',
    'checklist_item' => 'field_perm_card_create',
  ];

  // Workspace creation - allow for authenticated users by default.
  // Workspace creation doesn't belong to an existing workspace.
  if ($type === 'workspace') {
    if ($account->isAuthenticated()) {
      return AccessResult::allowed()->cachePerUser();
    }
    return AccessResult::forbidden()->cachePerUser();
  }

  // For board creation, get workspace from the node being created.
  if ($type === 'board') {
    if (!$node->hasField('field_board_workspace') || $node->get('field_board_workspace')->isEmpty()) {
      // No workspace specified - deny for security.
      return AccessResult::forbidden()
        ->cachePerUser()
        ->addCacheableDependency($node);
    }
    $workspace = $node->get('field_board_workspace')->entity;
    if (!$workspace) {
      return AccessResult::forbidden()
        ->cachePerUser()
        ->addCacheableDependency($node);
    }

    $permission_field = $create_permission_map[$type];
    $has_permission = $permission_checker->checkPermission(
      $permission_field,
      $workspace->uuid(),
      NULL,
      $account->id()
    );

    if ($has_permission) {
      return AccessResult::allowed()
        ->cachePerUser()
        ->addCacheableDependency($workspace)
        ->addCacheTags(['node_list:member_role']);
    }

    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($workspace)
      ->addCacheTags(['node_list:member_role']);
  }

  // For card, list, and related types, get board first then workspace.
  $board = boxtasks_role_get_board_for_entity($node, $type);
  if (!$board) {
    // No board found - deny access for security.
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node);
  }

  // Check if user can view the board first.
  $can_view_board = $permission_checker->canViewBoard($board, (int) $account->id());
  if (!$can_view_board) {
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board)
      ->addCacheTags(['node_list:member_role']);
  }

  // Get workspace from board.
  if (!$board->hasField('field_board_workspace') || $board->get('field_board_workspace')->isEmpty()) {
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board);
  }
  $workspace = $board->get('field_board_workspace')->entity;
  if (!$workspace) {
    return AccessResult::forbidden()
      ->cachePerUser()
      ->addCacheableDependency($node)
      ->addCacheableDependency($board);
  }

  // Check create permission.
  $permission_field = $create_permission_map[$type] ?? NULL;
  if (!$permission_field) {
    return AccessResult::neutral();
  }

  $has_permission = $permission_checker->checkPermission(
    $permission_field,
    $workspace->uuid(),
    NULL,
    $account->id()
  );

  if ($has_permission) {
    return AccessResult::allowed()
      ->cachePerUser()
      ->addCacheableDependency($board)
      ->addCacheableDependency($workspace)
      ->addCacheTags(['node_list:member_role']);
  }

  return AccessResult::forbidden()
    ->cachePerUser()
    ->addCacheableDependency($board)
    ->addCacheableDependency($workspace)
    ->addCacheTags(['node_list:member_role']);
}

/**
 * Check if a user is a super admin (Box Admin).
 *
 * Super admin is:
 * - uid = 1, OR
 * - user has 'administer nodes' permission
 *
 * @param \Drupal\Core\Session\AccountInterface $account
 *   The user account to check.
 *
 * @return bool
 *   TRUE if the user is a super admin.
 */
function boxtasks_role_is_super_admin(AccountInterface $account): bool {
  // uid = 1 is always super admin.
  if ((int) $account->id() === 1) {
    return TRUE;
  }

  // Users with 'administer nodes' permission are also super admins.
  return $account->hasPermission('administer nodes');
}

/**
 * Implements hook_node_access_records().
 *
 * Grant authenticated users access to workspace_role and member_role nodes.
 * These nodes are needed for role management and member assignment.
 */
function boxtasks_role_node_access_records(NodeInterface $node) {
  $type = $node->bundle();

  // Only handle workspace_role and member_role
  if (!in_array($type, ['workspace_role', 'member_role'])) {
    return [];
  }

  // Grant view access to all authenticated users
  return [
    [
      'realm' => 'boxtasks_role_authenticated',
      'gid' => 1, // Group ID 1 for authenticated users
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
    ],
  ];
}

/**
 * Implements hook_node_grants().
 *
 * Grant access to authenticated users for workspace_role and member_role nodes.
 */
function boxtasks_role_node_grants(AccountInterface $account, $op) {
  $grants = [];

  // Grant authenticated users access to workspace_role and member_role
  if ($account->isAuthenticated() && $op === 'view') {
    $grants['boxtasks_role_authenticated'] = [1];
  }

  return $grants;
}
